# Linux eBPF JIT verification

## Requirements

- [Racket] (tested on v7.5)
- [Serval]

After installing Racket, you can a good version of Serval with

```sh
git clone --recursive 'https://github.com/uw-unsat/bpf-jit-verif.git'
cd bpf-jit-verif
raco pkg install --auto ./serval
```

## Directory structure

`lib/bpf-common.rkt` contains the BPF JIT correctness
specification and other common BPF functionality.

`lib/riscv-common.rkt` provides features specific
to the JIT for the RISC-V ISA.

`rv64/bpf_jit_riscv64.c` contains the C implementation
of the BPF JIT for rv64 from Linux.

`rv64/bpf_jit_riscv64.rkt` is a manual translation
of the C implementation into Rosette for verification.

`rv64/test/` contains verification test cases for
different classes of instructions.

## Running verification

```sh
raco test --jobs 8 rv64/test/*.rkt
```

runs all of the verification test cases in parallel
using 8 jobs. It takes around 45 minutes to complete
on a modern desktop machine. You can also run
individual files for a specific class of instructions,
e.g.,

```sh
raco test rv64/test/riscv64-alu64-x.rkt
```

## Verification

The verifier works by proving refinement on a per-instruction type
basis between the BPF instruction and the RISC-V instructions
generated by the JIT.

As a simple concrete example, consider verifying
the `BPF_ALU | BPF_ADD | BPF_X`
instruction. The verifier starts by constructing a symbolic
BPF instruction where the destination and source register
fields can take on any value:

```
BPF_ALU32_REG(BPF_ADD, {{rd}}, {{rs}})
```

Next, the verifier symbolically evaluates
the JIT on the BPF
instruction, producing a sequence of symbolic RISC-V instructions:

```
addw {{rv_reg(rd)}} {{rv_reg(rd)}} {{rv_reg(rs)}}
slli {{rv_reg(rd)}} {{rv_reg(rd)}} 32
srli {{rv_reg(rd)}} {{rv_reg(rd)}} 32
```

Here, `rv_reg` denotes the RISC-V register associated
with a particular BPF register.

Next, the verifier
has to prove that this sequence of generated RISC-V
instructions has the same behavior as the BPF instruction,
for all possible choices of registers `rd` and `rs`, and
for all initial values of all RISC-V general-purpose
registers. To do so, it leverages automated verifiers provided
by the [Serval] verification framework, which can symbolically
evaluate BPF and RISC-V programs.

The verifier starts with a symbolic BPF state and symbolic
RISC-V state, called `bpf-state` and `riscv-state`.
It initially assumes that these states match, e.g.,
`riscv-state[rv_reg(reg)] == bpf-state[reg]` for all `reg`.
Next, it runs the Serval BPF and RISC-V verifiers
on the BPF instruction and RISC-V instructions, respectively.
BPF instruction on the BPF state, and the RISC-V instructions
on the RISC-V state. It then proves that, regardless of the
initial state, the BPF and RISC-V states still match.

Support for more complex instructions, such as jumps and branches,
requires additional care. For the details, you can see
the JIT correctness definition in `lib/bpf-common.rkt:verify-jit-refinement`. This complexity comes
from having to prove that the generated instructions
preserve a correspondance between the BPF program counter
and the RISC-V program counter.

## What is verified?

The test cases under `rv64/test` show which instructions
the JIT is currently verified for. For these instructions,
it proves that the JIT is correct for all possible initial
register values, for all jump offsets, for all immediate values,
etc.

- All `BPF_ALU64 | BPF_X` instructions.
- All `BPF_ALU | BPF_X` instructions.
- All `BPF_ALU64 | BPF_K` instructions, except `MUL`, `DIV`, and `MOD`, which are tested, but not verified.
- All `BPF_ALU | BPF_K` instructions, except `MUL`, `DIV`, and `MOD`, which are tested, but not verified.
- All (`BPF_JMP`, `BPF_JMP32`) instructions, except
  for `BPF_CALL`, `BPF_EXIT`, and `BPF_TAIL_CALL`.

## Caveats / limitations

There are several properties of the JIT that
are currently not specified or verified:

- Memory instructions (e.g. `BPF_LD`, `BPF_ST`, etc.)
- JIT prologue and epilogue
- Call instructions (e.g., `BPF_CALL`, `BPF_TAIL_CALL`)
- `build_body`: the verification proves the JIT correct
  for individual BPF instructions at a time
- The loop in `bpf_int_jit_compile`: verification assumes
  the `ctx->offset` mapping has already been correctly
  constructed by previous iterations.
- Non-linear arithmetic operations with immediate operands
  (e.g, `BPF_MUL | BPF_K`). These are difficult for solvers
  to reason about, so instead the verifier performs random
  testing.
- The verified JIT is a manual Rosette port of the C version:
  mismatches in this translation can mean there are bugs
  in the C version not present in the verified one.
- The verification assumes that the BPF program being compiled
  passed the kernel's BPF verifier: e.g., it assumes no
  divide-by-zero or out-of-range shifts.
- Verification makes assumptions on the total size of the
  compiled BPF program for jumps: it assumes that the number of BPF
  instructions is less than 1,048,576; and that the total number
  of generated RISC-V instructions is less than 8,388,608.

[Racket]: https://racket-lang.org
[Serval]: https://github.com/uw-unsat/serval.git
